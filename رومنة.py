# -*- coding: utf-8 -*-

import re

########################################
# 1) القواميس والقوائم الأساسية
########################################

# حروف عربية إلى رومنة أساسية (قصيرة)
# لاحظ أننا أضفنا همزة 'أ' كرمز 'ʾ' (أو يُمكن استخدام ('))
basic_letters_map = {
    'أ': 'ʾ',  # يمكن اختيار "'" بدل "ʾ" لو أحببت
    'إ': 'ʾ',
    'ؤ': 'ʾ',
    'ئ': 'ʾ',
    'ء': 'ʾ',  # الهمزة المنفصلة
    'ا': '',   # الألف إذا لم تكن ممدودة أو ظاهرة
    'ب': 'b',
    'ت': 't',
    'ث': 'th',
    'ج': 'j',
    'ح': 'ḥ',
    'خ': 'kh',
    'د': 'd',
    'ذ': 'dh',
    'ر': 'r',
    'ز': 'z',
    'س': 's',
    'ش': 'sh',
    'ص': 'ṣ',
    'ض': 'ḍ',
    'ط': 'ṭ',
    'ظ': 'ẓ',
    'ع': '‘',
    'غ': 'gh',
    'ف': 'f',
    'ق': 'q',
    'ك': 'k',
    'ل': 'l',
    'م': 'm',
    'ن': 'n',
    'ه': 'h',
    'و': 'w',   # لاحقًا نحدد إن كانت 'ū'
    'ي': 'y'    # لاحقًا نحدد إن كانت 'ī'
}

# الحركات القصيرة
short_vowels_map = {
    'َ': 'a',
    'ُ': 'u',
    'ِ': 'i'
}

# حركات طويلة/مدّ
long_vowels_map = {
    'ا': 'ā',  # مد بالألف
    'و': 'ū',  # مد بالواو
    'ي': 'ī'   # مد بالياء
}

# تنوين
tanween_map = {
    'ً': 'an',
    'ٌ': 'un',
    'ٍ': 'in'
}

# الحروف الشمسية
sun_letters = set(['ت','ث','د','ذ','ر','ز','س','ش','ص','ض','ط','ظ','ل','ن'])

# كلمات خاصة exceptions
special_words = {
    'الله': 'Allāh',
    'طه': 'Ṭāhā',
    'يس': 'Yāsīn',
    'ابن': 'ibn',
    'بن': 'ibn'
}

########################################
# 2) دوال مساعدة
########################################

def is_arabic_letter(ch):
    """يتحقق إن كان الحرف ضمن نطاق الحروف العربية."""
    return '\u0600' <= ch <= '\u06FF'

def is_sun_letter(ch):
    """يتحقق هل الحرف من الحروف الشمسية."""
    return ch in sun_letters

def strip_diacritics(text):
    """
    دالّة اختيارية لإزالة كل التشكيل (الحركات) من النص
    إذا كنت تريد معالجة نص غير مشكّل بشكل مبدئي.
    """
    arabic_diacritics = re.compile(r"[ًٌٍَُِّْ]")
    return re.sub(arabic_diacritics, '', text)

def handle_shadda(letters):
    """
    لو وجدنا شدة (ّ)، نكرر الحرف السابق في الرومنة.
    سنعالجه في مستوى الكلمة (سيتم شرح ذلك).
    """
    # سننفذه في دالة romanize_word
    return letters

########################################
# 3) دوال الرومنة للمكوّنات
########################################

def romanize_letter(ch):
    """
    تحوّل الحرف العربي الأساسي (بدون تشكيل) إلى رومنة.
    """
    return basic_letters_map.get(ch, ch)

def romanize_short_vowel(ch):
    """تُعيد الرومنة المقابلة للحركات القصيرة."""
    return short_vowels_map.get(ch, '')

def romanize_long_vowel(ch):
    """تُعيد الرومنة المناسبة للمدّ (آ، و، ي) إذا كانت فعلاً مدّ."""
    return long_vowels_map.get(ch, '')

def romanize_tanween(ch):
    """تُعيد الرومنة المناسبة للتنوين."""
    return tanween_map.get(ch, '')

########################################
# 4) دالة أساسية لمعالجة "كلمة" واحدة
########################################

def romanize_word(word):
    """
    تُعالِج كلمة عربية واحدة وفق القواعد:
      - التحقق إن كانت كلمة من special_words.
      - التعامل مع (ال) التعريف.
      - التعامل مع التاء المربوطة (ة).
      - التعامل مع الهمزات (بداية/وسط/نهاية).
      - الشدة (ّ).
      - المدّ (آ، ـا، ـو، ـي).
      - التنوين.
    """
    # 1) تحقّق هل الكلمة في قائمة الكلمات الخاصة:
    if word in special_words:
        return special_words[word]

    # 2) معالجة "ابن"/"بن" حتى لو جاءت في سياق أكبر (كأن تكون في نص)
    #    إذا أردت الدقة المطلقة، افصل النص أولاً لكلمات مفردة تمامًا.
    #    سنكتفي هنا بشرط المطابقة الكاملة:
    if word == 'ابن' or word == 'بن':
        return 'ibn'

    # 3) التعامل مع "ال" التعريف:
    #    إذا بدأت الكلمة بـ "ال" + حرف شمسي، نبدّلها بـ "a" + تكرار الحرف المشدّد
    #    أو بـ "al-" + حرف قمرّي.
    #    مثال: الشمس -> ash-shams
    #    نقوم بذلك قبل التعامل مع باقي الحروف.
    romanized = ""
    # نتحقق من حالة (ال) التعريف
    if len(word) > 2 and word.startswith('ال'):
        # الحرف التالي
        nxt = word[2]
        if is_sun_letter(nxt):
            # مثل "الشمس" -> 'a' + 'sh-shams'
            # لكننا سنحتاج تكرار الحرف التالي عند الشدة
            # لذا نضيف 'a' مؤقتًا ثم نتابع
            romanized += 'a'  # بدلاً من "al-"
            # نجعل المؤشر يتخطى "ال"
            # مع ملاحظة أننا سنُسقط اللام ونجعل الحرف التالي مشدّدًا
            rest = word[2:]  # الحرف الذي يلي "ال"
            # نضع شدة يدوية: (مثلاً: الشمس -> ash-shams)
            # hنا: سنعامله عند تحليل بقية الحروف
            # فلنحفظ علامة تدل أننا في وضع شمسي
            word = rest  # سنتابع تحليل بقية الحروف من rest
            # ولا ننسى لاحقًا سنكرر الحرف الأول
        else:
            # الحرف قمرّي
            romanized += 'al-'
            word = word[2:]  # نحذف "ال" من البداية

    # 4) الآن نعالج بقية الأحرف في الكلمة بعد (ال) إن وجدت:
    #    سنمر حرفًا حرفًا، ونراقب الشدة والتنوين والحركات
    i = 0
    while i < len(word):
        ch = word[i]

        # أ) التنوين
        if ch in tanween_map:
            romanized += romanize_tanween(ch)
            i += 1
            continue

        # ب) الحركات القصيرة (َ ِ ُ) - إن وجدت
        if ch in short_vowels_map:
            romanized += romanize_short_vowel(ch)
            i += 1
            continue

        # ج) الشدة
        if ch == 'ّ':
            # نكرر آخر حرف روماني أضفناه إن كان يتوافق مع حرف عربي
            # لكن يجب الحذر: قد يكون آخر حرف أضفناه يتبع حركة سابقة
            # أسهل: نكرر الحرف العربي السابق (لو موجود) في الرومنة
            if i > 0 and i-1 >= 0:
                prev_ch = word[i-1]
                # نجد رومنته ثم نكررها
                r_prev = romanize_letter(prev_ch)
                # لكن آخر ما أضفناه إلى romanized قد لا يكون بالضبط r_prev
                # لذا نضيف الرومن السابق مرة أخرى
                romanized += r_prev
            i += 1
            continue

        # د) التاء المربوطة "ة"
        #    - إذا كانت نهاية الكلمة وليس بعدها شيء، تحوّل إلى "h"
        #    - إذا شككنا بأنها في حالة إضافة (كلمة بعدها في نفس الجملة)، فتصير "t"
        #    هذه القاعدة قد تحتاج إلى سياق الجملة. هنا تبسيط:
        if ch == 'ة':
            # نفترض افتراضًا أنها نهاية الكلمة المستقلة -> h
            # أما في سياق الإضافة فنحتاج معلومات أكثر.
            # سنستخدم مثالًا مبسطًا: إن كان آخر حرف في الكلمة -> h
            # وإلا -> t
            if i == len(word) - 1:
                romanized += 'h'
            else:
                romanized += 't'
            i += 1
            continue

        # ه) الألف الممدودة (آ)
        #    قد تكون آ في بداية الكلمة -> Ā
        #    أو وسط الكلمة -> 'ā (مثل مآثر -> ma'āthir)
        # نميّزها عادةً بحرف (آ) Unicode: U+0622
        if ch == 'آ':
            if i == 0:
                # بداية الكلمة
                romanized += 'Ā'
            else:
                romanized += "'ā"
            i += 1
            continue

        # و) إذا الحرف (ا) لكنّه للمد: قد يكون النص مكتوبًا بدون تشكيل
        #    في حالة النص المُشَكّل: (ا) عليها مدّة -> نفصلها أعلاه
        #    خلاف ذلك، نعتمد على وجود حركات أو سياق الصرف.
        #    سنبسط الأمور:
        #    إذا جاءت "ا" بعد فتحة أو بداية الكلمة -> ā
        #    وهكذا. لكن هذا يتطلب تحليلًا أعمق.
        #    سنكتفي بالاستخدام الأساسي من القاموس: (ا -> '')
        #    أو الحركات الطويلة لو كان مشكّلا (ا -> ā) إذا سبقه فتحة

        # ز) إذا الحرف من (و/ي) ربما يكون مد: 
        #    لو وجدنا تشكيل يدل على ذلك (مثل: و مع ضمة طويلة؟ أو نص مشكل؟)
        #    في الكود الحالي سنعتمد على قواعد بسيطة.
        #    إن كان نصك مشكّلًا تمامًا، يمكنك التعامل بالتفصيل.

        # ح) نترجم الحرف الأساسي
        romanized_letter = romanize_letter(ch)
        romanized += romanized_letter

        i += 1

    return romanized


########################################
# 5) دالة رئيسية لمعالجة نص كامل
########################################

def romanize_text(text):
    """
    تقسم النص إلى كلمات + علامات ترقيم + مسافات،
    ثم تعالج كل 'مكوّن' على حدة.
    """
    # للاستفادة من علامات الترقيم والمسافات كما هي
    # سنستخدم ريجكس لتجزئة النص إلى tokens:
    # كلمات عربية + كلمات غير عربية + علامات ترقيم + مسافات...
    tokens = re.findall(r'[\u0600-\u06FF]+|[\w]+|[^\w\s]|[\s]+', text, flags=re.UNICODE)

    romanized_tokens = []

    for token in tokens:
        # إذا كانت كلمة عربية (تحتوي على حروف عربية) نعالجها بـ romanize_word
        if re.search(r'[\u0600-\u06FF]', token):
            # قد تكون مزيج (مثل: كلمة + حركات + أرقام...) ولكن سنبسط.
            romanized_token = romanize_word(token)
        else:
            # إن لم تكن عربية أو كانت علامة ترقيم أو مسافة، نتركها كما هي
            romanized_token = token
        romanized_tokens.append(romanized_token)

    # نجمع مرة أخرى
    return "".join(romanized_tokens)


########################################
# 6) تجربة الكود
########################################

if __name__ == "__main__":

    # مثال نص قصير لتجربة
    example_text = (
        "الله أكبر. الشمس مُشرِقة. طه ويس من الأعلام. ابن سينا. "
        "هذا نصّ تجريبي فيه التاء المربوطة (صلاة) والشدة (الشَّمْس). "
        "مآثر -> ma'āthir"
    )

    print("النص الأصلي:")
    print(example_text)
    print("\nالنص بالرومنة:")
    print(romanize_text(example_text))
